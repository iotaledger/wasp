// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

//nolint:dupl
package fairroulette

import "github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib"

var exportMap = wasmlib.ScExportMap{
	Names: []string{
		FuncForcePayout,
		FuncForceReset,
		FuncInit,
		FuncPayWinners,
		FuncPlaceBet,
		FuncPlayPeriod,
		ViewLastWinningNumber,
		ViewRoundNumber,
		ViewRoundStartedAt,
		ViewRoundStatus,
	},
	Funcs: []wasmlib.ScFuncContextFunction{
		funcForcePayoutThunk,
		funcForceResetThunk,
		funcInitThunk,
		funcPayWinnersThunk,
		funcPlaceBetThunk,
		funcPlayPeriodThunk,
	},
	Views: []wasmlib.ScViewContextFunction{
		viewLastWinningNumberThunk,
		viewRoundNumberThunk,
		viewRoundStartedAtThunk,
		viewRoundStatusThunk,
	},
}

func OnLoad(index int32) {
	if index >= 0 {
		wasmlib.ScExportsCall(index, &exportMap)
		return
	}

	wasmlib.ScExportsExport(&exportMap)
}

type ForcePayoutContext struct {
	Events FairRouletteEvents
	State  MutableFairRouletteState
}

func funcForcePayoutThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcForcePayout")
	f := &ForcePayoutContext{
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}

	// only SC owner can restart the round forcefully
	access := f.State.Owner()
	ctx.Require(access.Exists(), "access not set: owner")
	ctx.Require(ctx.Caller() == access.Value(), "no permission")

	funcForcePayout(ctx, f)
	ctx.Log("fairroulette.funcForcePayout ok")
}

type ForceResetContext struct {
	Events FairRouletteEvents
	State  MutableFairRouletteState
}

func funcForceResetThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcForceReset")
	f := &ForceResetContext{
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}

	// only SC owner can restart the round forcefully
	access := f.State.Owner()
	ctx.Require(access.Exists(), "access not set: owner")
	ctx.Require(ctx.Caller() == access.Value(), "no permission")

	funcForceReset(ctx, f)
	ctx.Log("fairroulette.funcForceReset ok")
}

type InitContext struct {
	Events FairRouletteEvents
	Params ImmutableInitParams
	State  MutableFairRouletteState
}

func funcInitThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcInit")
	f := &InitContext{
		Params: ImmutableInitParams{
			proxy: wasmlib.NewParamsProxy(),
		},
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	funcInit(ctx, f)
	ctx.Log("fairroulette.funcInit ok")
}

type PayWinnersContext struct {
	Events FairRouletteEvents
	State  MutableFairRouletteState
}

func funcPayWinnersThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPayWinners")
	f := &PayWinnersContext{
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}

	// only SC itself can invoke this function
	ctx.Require(ctx.Caller() == ctx.AccountID(), "no permission")

	funcPayWinners(ctx, f)
	ctx.Log("fairroulette.funcPayWinners ok")
}

type PlaceBetContext struct {
	Events FairRouletteEvents
	Params ImmutablePlaceBetParams
	State  MutableFairRouletteState
}

func funcPlaceBetThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPlaceBet")
	f := &PlaceBetContext{
		Params: ImmutablePlaceBetParams{
			proxy: wasmlib.NewParamsProxy(),
		},
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	ctx.Require(f.Params.Number().Exists(), "missing mandatory number")
	funcPlaceBet(ctx, f)
	ctx.Log("fairroulette.funcPlaceBet ok")
}

type PlayPeriodContext struct {
	Events FairRouletteEvents
	Params ImmutablePlayPeriodParams
	State  MutableFairRouletteState
}

func funcPlayPeriodThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPlayPeriod")
	f := &PlayPeriodContext{
		Params: ImmutablePlayPeriodParams{
			proxy: wasmlib.NewParamsProxy(),
		},
		State: MutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}

	// only SC owner can update the play period
	access := f.State.Owner()
	ctx.Require(access.Exists(), "access not set: owner")
	ctx.Require(ctx.Caller() == access.Value(), "no permission")

	ctx.Require(f.Params.PlayPeriod().Exists(), "missing mandatory playPeriod")
	funcPlayPeriod(ctx, f)
	ctx.Log("fairroulette.funcPlayPeriod ok")
}

type LastWinningNumberContext struct {
	Results MutableLastWinningNumberResults
	State   ImmutableFairRouletteState
}

func viewLastWinningNumberThunk(ctx wasmlib.ScViewContext) {
	ctx.Log("fairroulette.viewLastWinningNumber")
	results := wasmlib.NewScDict()
	f := &LastWinningNumberContext{
		Results: MutableLastWinningNumberResults{
			proxy: results.AsProxy(),
		},
		State: ImmutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	viewLastWinningNumber(ctx, f)
	ctx.Results(results)
	ctx.Log("fairroulette.viewLastWinningNumber ok")
}

type RoundNumberContext struct {
	Results MutableRoundNumberResults
	State   ImmutableFairRouletteState
}

func viewRoundNumberThunk(ctx wasmlib.ScViewContext) {
	ctx.Log("fairroulette.viewRoundNumber")
	results := wasmlib.NewScDict()
	f := &RoundNumberContext{
		Results: MutableRoundNumberResults{
			proxy: results.AsProxy(),
		},
		State: ImmutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	viewRoundNumber(ctx, f)
	ctx.Results(results)
	ctx.Log("fairroulette.viewRoundNumber ok")
}

type RoundStartedAtContext struct {
	Results MutableRoundStartedAtResults
	State   ImmutableFairRouletteState
}

func viewRoundStartedAtThunk(ctx wasmlib.ScViewContext) {
	ctx.Log("fairroulette.viewRoundStartedAt")
	results := wasmlib.NewScDict()
	f := &RoundStartedAtContext{
		Results: MutableRoundStartedAtResults{
			proxy: results.AsProxy(),
		},
		State: ImmutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	viewRoundStartedAt(ctx, f)
	ctx.Results(results)
	ctx.Log("fairroulette.viewRoundStartedAt ok")
}

type RoundStatusContext struct {
	Results MutableRoundStatusResults
	State   ImmutableFairRouletteState
}

func viewRoundStatusThunk(ctx wasmlib.ScViewContext) {
	ctx.Log("fairroulette.viewRoundStatus")
	results := wasmlib.NewScDict()
	f := &RoundStatusContext{
		Results: MutableRoundStatusResults{
			proxy: results.AsProxy(),
		},
		State: ImmutableFairRouletteState{
			proxy: wasmlib.NewStateProxy(),
		},
	}
	viewRoundStatus(ctx, f)
	ctx.Results(results)
	ctx.Log("fairroulette.viewRoundStatus ok")
}
