// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use fairroulette::*;
use wasmlib::*;

use crate::consts::*;
use crate::events::*;
use crate::params::*;
use crate::results::*;
use crate::state::*;
use crate::structs::*;

mod consts;
mod contract;
mod events;
mod params;
mod results;
mod state;
mod structs;

mod fairroulette;

#[no_mangle]
fn on_load() {
    let exports = ScExports::new();
    exports.add_func(FUNC_FORCE_PAYOUT,        func_force_payout_thunk);
    exports.add_func(FUNC_FORCE_RESET,         func_force_reset_thunk);
    exports.add_func(FUNC_PAY_WINNERS,         func_pay_winners_thunk);
    exports.add_func(FUNC_PLACE_BET,           func_place_bet_thunk);
    exports.add_func(FUNC_PLAY_PERIOD,         func_play_period_thunk);
    exports.add_view(VIEW_LAST_WINNING_NUMBER, view_last_winning_number_thunk);
    exports.add_view(VIEW_ROUND_NUMBER,        view_round_number_thunk);
    exports.add_view(VIEW_ROUND_STARTED_AT,    view_round_started_at_thunk);
    exports.add_view(VIEW_ROUND_STATUS,        view_round_status_thunk);
}

pub struct ForcePayoutContext {
	events:  FairRouletteEvents,
	state: MutableFairRouletteState,
}

fn func_force_payout_thunk(ctx: &ScFuncContext) {
	ctx.log("fairroulette.funcForcePayout");
	let f = ForcePayoutContext {
		events:  FairRouletteEvents {},
		state: MutableFairRouletteState { proxy: state_proxy() },
	};

	// only SC creator can restart the round forcefully
	ctx.require(ctx.caller() == ctx.contract_creator(), "no permission");

	func_force_payout(ctx, &f);
	ctx.log("fairroulette.funcForcePayout ok");
}

pub struct ForceResetContext {
	events:  FairRouletteEvents,
	state: MutableFairRouletteState,
}

fn func_force_reset_thunk(ctx: &ScFuncContext) {
	ctx.log("fairroulette.funcForceReset");
	let f = ForceResetContext {
		events:  FairRouletteEvents {},
		state: MutableFairRouletteState { proxy: state_proxy() },
	};

	// only SC creator can restart the round forcefully
	ctx.require(ctx.caller() == ctx.contract_creator(), "no permission");

	func_force_reset(ctx, &f);
	ctx.log("fairroulette.funcForceReset ok");
}

pub struct PayWinnersContext {
	events:  FairRouletteEvents,
	state: MutableFairRouletteState,
}

fn func_pay_winners_thunk(ctx: &ScFuncContext) {
	ctx.log("fairroulette.funcPayWinners");
	let f = PayWinnersContext {
		events:  FairRouletteEvents {},
		state: MutableFairRouletteState { proxy: state_proxy() },
	};

	// only SC itself can invoke this function
	ctx.require(ctx.caller() == ctx.account_id(), "no permission");

	func_pay_winners(ctx, &f);
	ctx.log("fairroulette.funcPayWinners ok");
}

pub struct PlaceBetContext {
	events:  FairRouletteEvents,
	params: ImmutablePlaceBetParams,
	state: MutableFairRouletteState,
}

fn func_place_bet_thunk(ctx: &ScFuncContext) {
	ctx.log("fairroulette.funcPlaceBet");
	let f = PlaceBetContext {
		events:  FairRouletteEvents {},
		params: ImmutablePlaceBetParams { proxy: params_proxy() },
		state: MutableFairRouletteState { proxy: state_proxy() },
	};
	ctx.require(f.params.number().exists(), "missing mandatory number");
	func_place_bet(ctx, &f);
	ctx.log("fairroulette.funcPlaceBet ok");
}

pub struct PlayPeriodContext {
	events:  FairRouletteEvents,
	params: ImmutablePlayPeriodParams,
	state: MutableFairRouletteState,
}

fn func_play_period_thunk(ctx: &ScFuncContext) {
	ctx.log("fairroulette.funcPlayPeriod");
	let f = PlayPeriodContext {
		events:  FairRouletteEvents {},
		params: ImmutablePlayPeriodParams { proxy: params_proxy() },
		state: MutableFairRouletteState { proxy: state_proxy() },
	};

	// only SC creator can update the play period
	ctx.require(ctx.caller() == ctx.contract_creator(), "no permission");

	ctx.require(f.params.play_period().exists(), "missing mandatory playPeriod");
	func_play_period(ctx, &f);
	ctx.log("fairroulette.funcPlayPeriod ok");
}

pub struct LastWinningNumberContext {
	results: MutableLastWinningNumberResults,
	state: ImmutableFairRouletteState,
}

fn view_last_winning_number_thunk(ctx: &ScViewContext) {
	ctx.log("fairroulette.viewLastWinningNumber");
	let f = LastWinningNumberContext {
		results: MutableLastWinningNumberResults { proxy: results_proxy() },
		state: ImmutableFairRouletteState { proxy: state_proxy() },
	};
	view_last_winning_number(ctx, &f);
	ctx.results(&f.results.proxy.kv_store);
	ctx.log("fairroulette.viewLastWinningNumber ok");
}

pub struct RoundNumberContext {
	results: MutableRoundNumberResults,
	state: ImmutableFairRouletteState,
}

fn view_round_number_thunk(ctx: &ScViewContext) {
	ctx.log("fairroulette.viewRoundNumber");
	let f = RoundNumberContext {
		results: MutableRoundNumberResults { proxy: results_proxy() },
		state: ImmutableFairRouletteState { proxy: state_proxy() },
	};
	view_round_number(ctx, &f);
	ctx.results(&f.results.proxy.kv_store);
	ctx.log("fairroulette.viewRoundNumber ok");
}

pub struct RoundStartedAtContext {
	results: MutableRoundStartedAtResults,
	state: ImmutableFairRouletteState,
}

fn view_round_started_at_thunk(ctx: &ScViewContext) {
	ctx.log("fairroulette.viewRoundStartedAt");
	let f = RoundStartedAtContext {
		results: MutableRoundStartedAtResults { proxy: results_proxy() },
		state: ImmutableFairRouletteState { proxy: state_proxy() },
	};
	view_round_started_at(ctx, &f);
	ctx.results(&f.results.proxy.kv_store);
	ctx.log("fairroulette.viewRoundStartedAt ok");
}

pub struct RoundStatusContext {
	results: MutableRoundStatusResults,
	state: ImmutableFairRouletteState,
}

fn view_round_status_thunk(ctx: &ScViewContext) {
	ctx.log("fairroulette.viewRoundStatus");
	let f = RoundStatusContext {
		results: MutableRoundStatusResults { proxy: results_proxy() },
		state: ImmutableFairRouletteState { proxy: state_proxy() },
	};
	view_round_status(ctx, &f);
	ctx.results(&f.results.proxy.kv_store);
	ctx.log("fairroulette.viewRoundStatus ok");
}
