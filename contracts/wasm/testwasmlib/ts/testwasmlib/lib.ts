// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "wasmlib";
import * as sc from "./index";

const exportMap: wasmlib.ScExportMap = {
	names: [
		sc.FuncArrayOfArraysAppend,
		sc.FuncArrayOfArraysClear,
		sc.FuncArrayOfArraysSet,
		sc.FuncArrayOfMapsClear,
		sc.FuncArrayOfMapsSet,
		sc.FuncMapOfArraysAppend,
		sc.FuncMapOfArraysClear,
		sc.FuncMapOfArraysSet,
		sc.FuncMapOfMapsClear,
		sc.FuncMapOfMapsSet,
		sc.FuncParamTypes,
		sc.FuncRandom,
		sc.FuncTakeAllowance,
		sc.FuncTakeBalance,
		sc.FuncTriggerEvent,
		sc.ViewArrayOfArraysLength,
		sc.ViewArrayOfArraysValue,
		sc.ViewArrayOfMapsValue,
		sc.ViewBlockRecord,
		sc.ViewBlockRecords,
		sc.ViewGetRandom,
		sc.ViewIotaBalance,
		sc.ViewMapOfArraysLength,
		sc.ViewMapOfArraysValue,
		sc.ViewMapOfMapsValue,
	],
	funcs: [
		funcArrayOfArraysAppendThunk,
		funcArrayOfArraysClearThunk,
		funcArrayOfArraysSetThunk,
		funcArrayOfMapsClearThunk,
		funcArrayOfMapsSetThunk,
		funcMapOfArraysAppendThunk,
		funcMapOfArraysClearThunk,
		funcMapOfArraysSetThunk,
		funcMapOfMapsClearThunk,
		funcMapOfMapsSetThunk,
		funcParamTypesThunk,
		funcRandomThunk,
		funcTakeAllowanceThunk,
		funcTakeBalanceThunk,
		funcTriggerEventThunk,
	],
	views: [
		viewArrayOfArraysLengthThunk,
		viewArrayOfArraysValueThunk,
		viewArrayOfMapsValueThunk,
		viewBlockRecordThunk,
		viewBlockRecordsThunk,
		viewGetRandomThunk,
		viewIotaBalanceThunk,
		viewMapOfArraysLengthThunk,
		viewMapOfArraysValueThunk,
		viewMapOfMapsValueThunk,
	],
};

export function on_call(index: i32): void {
	wasmlib.ScExports.call(index, exportMap);
}

export function on_load(): void {
	wasmlib.ScExports.export(exportMap);
}

function funcArrayOfArraysAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfArraysAppend");
	let f = new sc.ArrayOfArraysAppendContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	sc.funcArrayOfArraysAppend(ctx, f);
	ctx.log("testwasmlib.funcArrayOfArraysAppend ok");
}

function funcArrayOfArraysClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfArraysClear");
	let f = new sc.ArrayOfArraysClearContext();
	sc.funcArrayOfArraysClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfArraysClear ok");
}

function funcArrayOfArraysSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfArraysSet");
	let f = new sc.ArrayOfArraysSetContext();
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcArrayOfArraysSet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfArraysSet ok");
}

function funcArrayOfMapsClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfMapsClear");
	let f = new sc.ArrayOfMapsClearContext();
	sc.funcArrayOfMapsClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfMapsClear ok");
}

function funcArrayOfMapsSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfMapsSet");
	let f = new sc.ArrayOfMapsSetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcArrayOfMapsSet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfMapsSet ok");
}

function funcMapOfArraysAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcMapOfArraysAppend");
	let f = new sc.MapOfArraysAppendContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcMapOfArraysAppend(ctx, f);
	ctx.log("testwasmlib.funcMapOfArraysAppend ok");
}

function funcMapOfArraysClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcMapOfArraysClear");
	let f = new sc.MapOfArraysClearContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcMapOfArraysClear(ctx, f);
	ctx.log("testwasmlib.funcMapOfArraysClear ok");
}

function funcMapOfArraysSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcMapOfArraysSet");
	let f = new sc.MapOfArraysSetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcMapOfArraysSet(ctx, f);
	ctx.log("testwasmlib.funcMapOfArraysSet ok");
}

function funcMapOfMapsClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcMapOfMapsClear");
	let f = new sc.MapOfMapsClearContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcMapOfMapsClear(ctx, f);
	ctx.log("testwasmlib.funcMapOfMapsClear ok");
}

function funcMapOfMapsSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcMapOfMapsSet");
	let f = new sc.MapOfMapsSetContext();
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcMapOfMapsSet(ctx, f);
	ctx.log("testwasmlib.funcMapOfMapsSet ok");
}

function funcParamTypesThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcParamTypes");
	let f = new sc.ParamTypesContext();
	sc.funcParamTypes(ctx, f);
	ctx.log("testwasmlib.funcParamTypes ok");
}

function funcRandomThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcRandom");
	let f = new sc.RandomContext();
	sc.funcRandom(ctx, f);
	ctx.log("testwasmlib.funcRandom ok");
}

function funcTakeAllowanceThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTakeAllowance");
	let f = new sc.TakeAllowanceContext();
	sc.funcTakeAllowance(ctx, f);
	ctx.log("testwasmlib.funcTakeAllowance ok");
}

function funcTakeBalanceThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTakeBalance");
	let f = new sc.TakeBalanceContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableTakeBalanceResults(results.asProxy());
	sc.funcTakeBalance(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.funcTakeBalance ok");
}

function funcTriggerEventThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTriggerEvent");
	let f = new sc.TriggerEventContext();
	ctx.require(f.params.address().exists(), "missing mandatory address");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcTriggerEvent(ctx, f);
	ctx.log("testwasmlib.funcTriggerEvent ok");
}

function viewArrayOfArraysLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfArraysLength");
	let f = new sc.ArrayOfArraysLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfArraysLengthResults(results.asProxy());
	sc.viewArrayOfArraysLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfArraysLength ok");
}

function viewArrayOfArraysValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfArraysValue");
	let f = new sc.ArrayOfArraysValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfArraysValueResults(results.asProxy());
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	sc.viewArrayOfArraysValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfArraysValue ok");
}

function viewArrayOfMapsValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfMapsValue");
	let f = new sc.ArrayOfMapsValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfMapsValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.key().exists(), "missing mandatory key");
	sc.viewArrayOfMapsValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfMapsValue ok");
}

function viewBlockRecordThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBlockRecord");
	let f = new sc.BlockRecordContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBlockRecordResults(results.asProxy());
	ctx.require(f.params.blockIndex().exists(), "missing mandatory blockIndex");
	ctx.require(f.params.recordIndex().exists(), "missing mandatory recordIndex");
	sc.viewBlockRecord(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBlockRecord ok");
}

function viewBlockRecordsThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBlockRecords");
	let f = new sc.BlockRecordsContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBlockRecordsResults(results.asProxy());
	ctx.require(f.params.blockIndex().exists(), "missing mandatory blockIndex");
	sc.viewBlockRecords(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBlockRecords ok");
}

function viewGetRandomThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewGetRandom");
	let f = new sc.GetRandomContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableGetRandomResults(results.asProxy());
	sc.viewGetRandom(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewGetRandom ok");
}

function viewIotaBalanceThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewIotaBalance");
	let f = new sc.IotaBalanceContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableIotaBalanceResults(results.asProxy());
	sc.viewIotaBalance(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewIotaBalance ok");
}

function viewMapOfArraysLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewMapOfArraysLength");
	let f = new sc.MapOfArraysLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableMapOfArraysLengthResults(results.asProxy());
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewMapOfArraysLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewMapOfArraysLength ok");
}

function viewMapOfArraysValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewMapOfArraysValue");
	let f = new sc.MapOfArraysValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableMapOfArraysValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewMapOfArraysValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewMapOfArraysValue ok");
}

function viewMapOfMapsValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewMapOfMapsValue");
	let f = new sc.MapOfMapsValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableMapOfMapsValueResults(results.asProxy());
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewMapOfMapsValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewMapOfMapsValue ok");
}
