// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmtypes from "wasmlib/wasmtypes";

export class Token {
    created     : u64 = 0;  // creation timestamp
    description : string = "";  // description what minted token represents
    mintedBy    : wasmtypes.ScAgentID = wasmtypes.agentIDFromBytes([]);  // original minter
    owner       : wasmtypes.ScAgentID = wasmtypes.agentIDFromBytes([]);  // current owner
    supply      : u64 = 0;  // amount of tokens originally minted
    updated     : u64 = 0;  // last update timestamp
    userDefined : string = "";  // any user defined text

    static fromBytes(buf: u8[]): Token {
        const dec = new wasmtypes.WasmDecoder(buf);
        const data = new Token();
        data.created     = wasmtypes.uint64Decode(dec);
        data.description = wasmtypes.stringDecode(dec);
        data.mintedBy    = wasmtypes.agentIDDecode(dec);
        data.owner       = wasmtypes.agentIDDecode(dec);
        data.supply      = wasmtypes.uint64Decode(dec);
        data.updated     = wasmtypes.uint64Decode(dec);
        data.userDefined = wasmtypes.stringDecode(dec);
        dec.close();
        return data;
    }

    bytes(): u8[] {
        const enc = new wasmtypes.WasmEncoder();
		    wasmtypes.uint64Encode(enc, this.created);
		    wasmtypes.stringEncode(enc, this.description);
		    wasmtypes.agentIDEncode(enc, this.mintedBy);
		    wasmtypes.agentIDEncode(enc, this.owner);
		    wasmtypes.uint64Encode(enc, this.supply);
		    wasmtypes.uint64Encode(enc, this.updated);
		    wasmtypes.stringEncode(enc, this.userDefined);
        return enc.buf();
    }
}

export class ImmutableToken extends wasmtypes.ScProxy {

    exists(): bool {
        return this.proxy.exists();
    }

    value(): Token {
        return Token.fromBytes(this.proxy.get());
    }
}

export class MutableToken extends wasmtypes.ScProxy {

    delete(): void {
        this.proxy.delete();
    }

    exists(): bool {
        return this.proxy.exists();
    }

    setValue(value: Token): void {
        this.proxy.set(value.bytes());
    }

    value(): Token {
        return Token.fromBytes(this.proxy.get());
    }
}
