// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;

use crate::consts::*;
use crate::params::*;
use crate::results::*;

pub struct ApproveCall {
	pub func: ScFunc,
	pub params: MutableApproveParams,
}

pub struct BurnCall {
	pub func: ScFunc,
	pub params: MutableBurnParams,
}

pub struct InitCall {
	pub func: ScInitFunc,
	pub params: MutableInitParams,
}

pub struct MintCall {
	pub func: ScFunc,
	pub params: MutableMintParams,
}

pub struct SafeTransferFromCall {
	pub func: ScFunc,
	pub params: MutableSafeTransferFromParams,
}

pub struct SetApprovalForAllCall {
	pub func: ScFunc,
	pub params: MutableSetApprovalForAllParams,
}

pub struct TransferFromCall {
	pub func: ScFunc,
	pub params: MutableTransferFromParams,
}

pub struct BalanceOfCall {
	pub func: ScView,
	pub params: MutableBalanceOfParams,
	pub results: ImmutableBalanceOfResults,
}

pub struct GetApprovedCall {
	pub func: ScView,
	pub params: MutableGetApprovedParams,
	pub results: ImmutableGetApprovedResults,
}

pub struct IsApprovedForAllCall {
	pub func: ScView,
	pub params: MutableIsApprovedForAllParams,
	pub results: ImmutableIsApprovedForAllResults,
}

pub struct NameCall {
	pub func: ScView,
	pub results: ImmutableNameResults,
}

pub struct OwnerOfCall {
	pub func: ScView,
	pub params: MutableOwnerOfParams,
	pub results: ImmutableOwnerOfResults,
}

pub struct SymbolCall {
	pub func: ScView,
	pub results: ImmutableSymbolResults,
}

pub struct TokenURICall {
	pub func: ScView,
	pub params: MutableTokenURIParams,
	pub results: ImmutableTokenURIResults,
}

pub struct ScFuncs {
}

impl ScFuncs {
    pub fn approve(_ctx: &dyn ScFuncCallContext) -> ApproveCall {
        let mut f = ApproveCall {
            func: ScFunc::new(HSC_NAME, HFUNC_APPROVE),
            params: MutableApproveParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn burn(_ctx: &dyn ScFuncCallContext) -> BurnCall {
        let mut f = BurnCall {
            func: ScFunc::new(HSC_NAME, HFUNC_BURN),
            params: MutableBurnParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn init(_ctx: &dyn ScFuncCallContext) -> InitCall {
        let mut f = InitCall {
            func: ScInitFunc::new(HSC_NAME, HFUNC_INIT),
            params: MutableInitParams { proxy: Proxy::nil() },
        };
        ScInitFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn mint(_ctx: &dyn ScFuncCallContext) -> MintCall {
        let mut f = MintCall {
            func: ScFunc::new(HSC_NAME, HFUNC_MINT),
            params: MutableMintParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn safe_transfer_from(_ctx: &dyn ScFuncCallContext) -> SafeTransferFromCall {
        let mut f = SafeTransferFromCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SAFE_TRANSFER_FROM),
            params: MutableSafeTransferFromParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn set_approval_for_all(_ctx: &dyn ScFuncCallContext) -> SetApprovalForAllCall {
        let mut f = SetApprovalForAllCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SET_APPROVAL_FOR_ALL),
            params: MutableSetApprovalForAllParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn transfer_from(_ctx: &dyn ScFuncCallContext) -> TransferFromCall {
        let mut f = TransferFromCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TRANSFER_FROM),
            params: MutableTransferFromParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn balance_of(_ctx: &dyn ScViewCallContext) -> BalanceOfCall {
        let mut f = BalanceOfCall {
            func: ScView::new(HSC_NAME, HVIEW_BALANCE_OF),
            params: MutableBalanceOfParams { proxy: Proxy::nil() },
            results: ImmutableBalanceOfResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn get_approved(_ctx: &dyn ScViewCallContext) -> GetApprovedCall {
        let mut f = GetApprovedCall {
            func: ScView::new(HSC_NAME, HVIEW_GET_APPROVED),
            params: MutableGetApprovedParams { proxy: Proxy::nil() },
            results: ImmutableGetApprovedResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn is_approved_for_all(_ctx: &dyn ScViewCallContext) -> IsApprovedForAllCall {
        let mut f = IsApprovedForAllCall {
            func: ScView::new(HSC_NAME, HVIEW_IS_APPROVED_FOR_ALL),
            params: MutableIsApprovedForAllParams { proxy: Proxy::nil() },
            results: ImmutableIsApprovedForAllResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn name(_ctx: &dyn ScViewCallContext) -> NameCall {
        let mut f = NameCall {
            func: ScView::new(HSC_NAME, HVIEW_NAME),
            results: ImmutableNameResults { proxy: Proxy::nil() },
        };
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn owner_of(_ctx: &dyn ScViewCallContext) -> OwnerOfCall {
        let mut f = OwnerOfCall {
            func: ScView::new(HSC_NAME, HVIEW_OWNER_OF),
            params: MutableOwnerOfParams { proxy: Proxy::nil() },
            results: ImmutableOwnerOfResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn symbol(_ctx: &dyn ScViewCallContext) -> SymbolCall {
        let mut f = SymbolCall {
            func: ScView::new(HSC_NAME, HVIEW_SYMBOL),
            results: ImmutableSymbolResults { proxy: Proxy::nil() },
        };
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn token_uri(_ctx: &dyn ScViewCallContext) -> TokenURICall {
        let mut f = TokenURICall {
            func: ScView::new(HSC_NAME, HVIEW_TOKEN_URI),
            params: MutableTokenURIParams { proxy: Proxy::nil() },
            results: ImmutableTokenURIResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }
}
