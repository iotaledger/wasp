// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

package erc721

import "github.com/iotaledger/wasp/packages/vm/wasmlib/go/wasmlib"

type ApproveCall struct {
	Func   *wasmlib.ScFunc
	Params MutableApproveParams
}

type BurnCall struct {
	Func   *wasmlib.ScFunc
	Params MutableBurnParams
}

type InitCall struct {
	Func   *wasmlib.ScInitFunc
	Params MutableInitParams
}

type MintCall struct {
	Func   *wasmlib.ScFunc
	Params MutableMintParams
}

type SafeTransferFromCall struct {
	Func   *wasmlib.ScFunc
	Params MutableSafeTransferFromParams
}

type SetApprovalForAllCall struct {
	Func   *wasmlib.ScFunc
	Params MutableSetApprovalForAllParams
}

type TransferFromCall struct {
	Func   *wasmlib.ScFunc
	Params MutableTransferFromParams
}

type BalanceOfCall struct {
	Func    *wasmlib.ScView
	Params  MutableBalanceOfParams
	Results ImmutableBalanceOfResults
}

type GetApprovedCall struct {
	Func    *wasmlib.ScView
	Params  MutableGetApprovedParams
	Results ImmutableGetApprovedResults
}

type IsApprovedForAllCall struct {
	Func    *wasmlib.ScView
	Params  MutableIsApprovedForAllParams
	Results ImmutableIsApprovedForAllResults
}

type NameCall struct {
	Func    *wasmlib.ScView
	Results ImmutableNameResults
}

type OwnerOfCall struct {
	Func    *wasmlib.ScView
	Params  MutableOwnerOfParams
	Results ImmutableOwnerOfResults
}

type SymbolCall struct {
	Func    *wasmlib.ScView
	Results ImmutableSymbolResults
}

type TokenURICall struct {
	Func    *wasmlib.ScView
	Params  MutableTokenURIParams
	Results ImmutableTokenURIResults
}

type Funcs struct{}

var ScFuncs Funcs

func (sc Funcs) Approve(ctx wasmlib.ScFuncCallContext) *ApproveCall {
	f := &ApproveCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncApprove)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) Burn(ctx wasmlib.ScFuncCallContext) *BurnCall {
	f := &BurnCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncBurn)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) Init(ctx wasmlib.ScFuncCallContext) *InitCall {
	f := &InitCall{Func: wasmlib.NewScInitFunc(ctx, HScName, HFuncInit)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) Mint(ctx wasmlib.ScFuncCallContext) *MintCall {
	f := &MintCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncMint)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) SafeTransferFrom(ctx wasmlib.ScFuncCallContext) *SafeTransferFromCall {
	f := &SafeTransferFromCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncSafeTransferFrom)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) SetApprovalForAll(ctx wasmlib.ScFuncCallContext) *SetApprovalForAllCall {
	f := &SetApprovalForAllCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncSetApprovalForAll)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) TransferFrom(ctx wasmlib.ScFuncCallContext) *TransferFromCall {
	f := &TransferFromCall{Func: wasmlib.NewScFunc(ctx, HScName, HFuncTransferFrom)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(&f.Func.ScView)
	return f
}

func (sc Funcs) BalanceOf(ctx wasmlib.ScViewCallContext) *BalanceOfCall {
	f := &BalanceOfCall{Func: wasmlib.NewScView(ctx, HScName, HViewBalanceOf)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) GetApproved(ctx wasmlib.ScViewCallContext) *GetApprovedCall {
	f := &GetApprovedCall{Func: wasmlib.NewScView(ctx, HScName, HViewGetApproved)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) IsApprovedForAll(ctx wasmlib.ScViewCallContext) *IsApprovedForAllCall {
	f := &IsApprovedForAllCall{Func: wasmlib.NewScView(ctx, HScName, HViewIsApprovedForAll)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) Name(ctx wasmlib.ScViewCallContext) *NameCall {
	f := &NameCall{Func: wasmlib.NewScView(ctx, HScName, HViewName)}
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) OwnerOf(ctx wasmlib.ScViewCallContext) *OwnerOfCall {
	f := &OwnerOfCall{Func: wasmlib.NewScView(ctx, HScName, HViewOwnerOf)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) Symbol(ctx wasmlib.ScViewCallContext) *SymbolCall {
	f := &SymbolCall{Func: wasmlib.NewScView(ctx, HScName, HViewSymbol)}
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}

func (sc Funcs) TokenURI(ctx wasmlib.ScViewCallContext) *TokenURICall {
	f := &TokenURICall{Func: wasmlib.NewScView(ctx, HScName, HViewTokenURI)}
	f.Params.proxy = wasmlib.NewCallParamsProxy(f.Func)
	wasmlib.NewCallResultsProxy(f.Func, &f.Results.proxy)
	return f
}
