// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "wasmlib";
import * as sc from "./index";

export function on_call(index: i32): void {
    return wasmlib.onCall(index);
}

export function on_load(): void {
    let exports = new wasmlib.ScExports();
    exports.addFunc(sc.FuncCallOnChain,                 funcCallOnChainThunk);
    exports.addFunc(sc.FuncCheckContextFromFullEP,      funcCheckContextFromFullEPThunk);
    exports.addFunc(sc.FuncDoNothing,                   funcDoNothingThunk);
    exports.addFunc(sc.FuncGetMintedSupply,             funcGetMintedSupplyThunk);
    exports.addFunc(sc.FuncIncCounter,                  funcIncCounterThunk);
    exports.addFunc(sc.FuncInit,                        funcInitThunk);
    exports.addFunc(sc.FuncPassTypesFull,               funcPassTypesFullThunk);
    exports.addFunc(sc.FuncRunRecursion,                funcRunRecursionThunk);
    exports.addFunc(sc.FuncSendToAddress,               funcSendToAddressThunk);
    exports.addFunc(sc.FuncSetInt,                      funcSetIntThunk);
    exports.addFunc(sc.FuncSpawn,                       funcSpawnThunk);
    exports.addFunc(sc.FuncTestBlockContext1,           funcTestBlockContext1Thunk);
    exports.addFunc(sc.FuncTestBlockContext2,           funcTestBlockContext2Thunk);
    exports.addFunc(sc.FuncTestCallPanicFullEP,         funcTestCallPanicFullEPThunk);
    exports.addFunc(sc.FuncTestCallPanicViewEPFromFull, funcTestCallPanicViewEPFromFullThunk);
    exports.addFunc(sc.FuncTestChainOwnerIDFull,        funcTestChainOwnerIDFullThunk);
    exports.addFunc(sc.FuncTestEventLogDeploy,          funcTestEventLogDeployThunk);
    exports.addFunc(sc.FuncTestEventLogEventData,       funcTestEventLogEventDataThunk);
    exports.addFunc(sc.FuncTestEventLogGenericData,     funcTestEventLogGenericDataThunk);
    exports.addFunc(sc.FuncTestPanicFullEP,             funcTestPanicFullEPThunk);
    exports.addFunc(sc.FuncWithdrawToChain,             funcWithdrawToChainThunk);
    exports.addView(sc.ViewCheckContextFromViewEP,      viewCheckContextFromViewEPThunk);
    exports.addView(sc.ViewFibonacci,                   viewFibonacciThunk);
    exports.addView(sc.ViewGetCounter,                  viewGetCounterThunk);
    exports.addView(sc.ViewGetInt,                      viewGetIntThunk);
    exports.addView(sc.ViewGetStringValue,              viewGetStringValueThunk);
    exports.addView(sc.ViewJustView,                    viewJustViewThunk);
    exports.addView(sc.ViewPassTypesView,               viewPassTypesViewThunk);
    exports.addView(sc.ViewTestCallPanicViewEPFromView, viewTestCallPanicViewEPFromViewThunk);
    exports.addView(sc.ViewTestChainOwnerIDView,        viewTestChainOwnerIDViewThunk);
    exports.addView(sc.ViewTestPanicViewEP,             viewTestPanicViewEPThunk);
    exports.addView(sc.ViewTestSandboxCall,             viewTestSandboxCallThunk);

    for (let i = 0; i < sc.keyMap.length; i++) {
        sc.idxMap[i] = wasmlib.Key32.fromString(sc.keyMap[i]);
    }
}

function funcCallOnChainThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcCallOnChain");
	let f = new sc.CallOnChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.intValue().exists(), "missing mandatory intValue");
	sc.funcCallOnChain(ctx, f);
	ctx.log("testcore.funcCallOnChain ok");
}

function funcCheckContextFromFullEPThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcCheckContextFromFullEP");
	let f = new sc.CheckContextFromFullEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.agentID().exists(), "missing mandatory agentID");
	ctx.require(f.params.caller().exists(), "missing mandatory caller");
	ctx.require(f.params.chainID().exists(), "missing mandatory chainID");
	ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID");
	ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator");
	sc.funcCheckContextFromFullEP(ctx, f);
	ctx.log("testcore.funcCheckContextFromFullEP ok");
}

function funcDoNothingThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcDoNothing");
	let f = new sc.DoNothingContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcDoNothing(ctx, f);
	ctx.log("testcore.funcDoNothing ok");
}

function funcGetMintedSupplyThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcGetMintedSupply");
	let f = new sc.GetMintedSupplyContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcGetMintedSupply(ctx, f);
	ctx.log("testcore.funcGetMintedSupply ok");
}

function funcIncCounterThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcIncCounter");
	let f = new sc.IncCounterContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcIncCounter(ctx, f);
	ctx.log("testcore.funcIncCounter ok");
}

function funcInitThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcInit");
	let f = new sc.InitContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcInit(ctx, f);
	ctx.log("testcore.funcInit ok");
}

function funcPassTypesFullThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcPassTypesFull");
	let f = new sc.PassTypesFullContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.address().exists(), "missing mandatory address");
	ctx.require(f.params.agentID().exists(), "missing mandatory agentID");
	ctx.require(f.params.chainID().exists(), "missing mandatory chainID");
	ctx.require(f.params.contractID().exists(), "missing mandatory contractID");
	ctx.require(f.params.hash().exists(), "missing mandatory hash");
	ctx.require(f.params.hname().exists(), "missing mandatory hname");
	ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero");
	ctx.require(f.params.int64().exists(), "missing mandatory int64");
	ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero");
	ctx.require(f.params.string().exists(), "missing mandatory string");
	ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero");
	sc.funcPassTypesFull(ctx, f);
	ctx.log("testcore.funcPassTypesFull ok");
}

function funcRunRecursionThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcRunRecursion");
	let f = new sc.RunRecursionContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.intValue().exists(), "missing mandatory intValue");
	sc.funcRunRecursion(ctx, f);
	ctx.log("testcore.funcRunRecursion ok");
}

function funcSendToAddressThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcSendToAddress");
	ctx.require(ctx.caller().equals(ctx.contractCreator()), "no permission");

	let f = new sc.SendToAddressContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.address().exists(), "missing mandatory address");
	sc.funcSendToAddress(ctx, f);
	ctx.log("testcore.funcSendToAddress ok");
}

function funcSetIntThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcSetInt");
	let f = new sc.SetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.intValue().exists(), "missing mandatory intValue");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcSetInt(ctx, f);
	ctx.log("testcore.funcSetInt ok");
}

function funcSpawnThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcSpawn");
	let f = new sc.SpawnContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.progHash().exists(), "missing mandatory progHash");
	sc.funcSpawn(ctx, f);
	ctx.log("testcore.funcSpawn ok");
}

function funcTestBlockContext1Thunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestBlockContext1");
	let f = new sc.TestBlockContext1Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestBlockContext1(ctx, f);
	ctx.log("testcore.funcTestBlockContext1 ok");
}

function funcTestBlockContext2Thunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestBlockContext2");
	let f = new sc.TestBlockContext2Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestBlockContext2(ctx, f);
	ctx.log("testcore.funcTestBlockContext2 ok");
}

function funcTestCallPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestCallPanicFullEP");
	let f = new sc.TestCallPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestCallPanicFullEP(ctx, f);
	ctx.log("testcore.funcTestCallPanicFullEP ok");
}

function funcTestCallPanicViewEPFromFullThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestCallPanicViewEPFromFull");
	let f = new sc.TestCallPanicViewEPFromFullContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestCallPanicViewEPFromFull(ctx, f);
	ctx.log("testcore.funcTestCallPanicViewEPFromFull ok");
}

function funcTestChainOwnerIDFullThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestChainOwnerIDFull");
	let f = new sc.TestChainOwnerIDFullContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestChainOwnerIDFull(ctx, f);
	ctx.log("testcore.funcTestChainOwnerIDFull ok");
}

function funcTestEventLogDeployThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestEventLogDeploy");
	let f = new sc.TestEventLogDeployContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestEventLogDeploy(ctx, f);
	ctx.log("testcore.funcTestEventLogDeploy ok");
}

function funcTestEventLogEventDataThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestEventLogEventData");
	let f = new sc.TestEventLogEventDataContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestEventLogEventData(ctx, f);
	ctx.log("testcore.funcTestEventLogEventData ok");
}

function funcTestEventLogGenericDataThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestEventLogGenericData");
	let f = new sc.TestEventLogGenericDataContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.counter().exists(), "missing mandatory counter");
	sc.funcTestEventLogGenericData(ctx, f);
	ctx.log("testcore.funcTestEventLogGenericData ok");
}

function funcTestPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcTestPanicFullEP");
	let f = new sc.TestPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.funcTestPanicFullEP(ctx, f);
	ctx.log("testcore.funcTestPanicFullEP ok");
}

function funcWithdrawToChainThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testcore.funcWithdrawToChain");
	let f = new sc.WithdrawToChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.chainID().exists(), "missing mandatory chainID");
	sc.funcWithdrawToChain(ctx, f);
	ctx.log("testcore.funcWithdrawToChain ok");
}

function viewCheckContextFromViewEPThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewCheckContextFromViewEP");
	let f = new sc.CheckContextFromViewEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.agentID().exists(), "missing mandatory agentID");
	ctx.require(f.params.chainID().exists(), "missing mandatory chainID");
	ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID");
	ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator");
	sc.viewCheckContextFromViewEP(ctx, f);
	ctx.log("testcore.viewCheckContextFromViewEP ok");
}

function viewFibonacciThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewFibonacci");
	let f = new sc.FibonacciContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.intValue().exists(), "missing mandatory intValue");
	sc.viewFibonacci(ctx, f);
	ctx.log("testcore.viewFibonacci ok");
}

function viewGetCounterThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewGetCounter");
	let f = new sc.GetCounterContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewGetCounter(ctx, f);
	ctx.log("testcore.viewGetCounter ok");
}

function viewGetIntThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewGetInt");
	let f = new sc.GetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewGetInt(ctx, f);
	ctx.log("testcore.viewGetInt ok");
}

function viewGetStringValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewGetStringValue");
	let f = new sc.GetStringValueContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.varName().exists(), "missing mandatory varName");
	sc.viewGetStringValue(ctx, f);
	ctx.log("testcore.viewGetStringValue ok");
}

function viewJustViewThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewJustView");
	let f = new sc.JustViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewJustView(ctx, f);
	ctx.log("testcore.viewJustView ok");
}

function viewPassTypesViewThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewPassTypesView");
	let f = new sc.PassTypesViewContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	ctx.require(f.params.address().exists(), "missing mandatory address");
	ctx.require(f.params.agentID().exists(), "missing mandatory agentID");
	ctx.require(f.params.chainID().exists(), "missing mandatory chainID");
	ctx.require(f.params.contractID().exists(), "missing mandatory contractID");
	ctx.require(f.params.hash().exists(), "missing mandatory hash");
	ctx.require(f.params.hname().exists(), "missing mandatory hname");
	ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero");
	ctx.require(f.params.int64().exists(), "missing mandatory int64");
	ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero");
	ctx.require(f.params.string().exists(), "missing mandatory string");
	ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero");
	sc.viewPassTypesView(ctx, f);
	ctx.log("testcore.viewPassTypesView ok");
}

function viewTestCallPanicViewEPFromViewThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewTestCallPanicViewEPFromView");
	let f = new sc.TestCallPanicViewEPFromViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewTestCallPanicViewEPFromView(ctx, f);
	ctx.log("testcore.viewTestCallPanicViewEPFromView ok");
}

function viewTestChainOwnerIDViewThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewTestChainOwnerIDView");
	let f = new sc.TestChainOwnerIDViewContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewTestChainOwnerIDView(ctx, f);
	ctx.log("testcore.viewTestChainOwnerIDView ok");
}

function viewTestPanicViewEPThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewTestPanicViewEP");
	let f = new sc.TestPanicViewEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewTestPanicViewEP(ctx, f);
	ctx.log("testcore.viewTestPanicViewEP ok");
}

function viewTestSandboxCallThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testcore.viewTestSandboxCall");
	let f = new sc.TestSandboxCallContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
	sc.viewTestSandboxCall(ctx, f);
	ctx.log("testcore.viewTestSandboxCall ok");
}
