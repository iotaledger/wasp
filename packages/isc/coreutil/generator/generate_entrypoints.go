package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"text/template"
)

var TemplateFuncs = template.FuncMap{
	"until": func(n int) []int {
		result := make([]int, n)
		for i := range result {
			result[i] = i
		}
		return result
	},
	"add": func(a, b int) int {
		return a + b
	},
	"last": func(i, slice int) bool {
		return i == slice-1
	},
}

func generateX(basePath string, maxX int) string {
	templateCode, err := os.ReadFile(path.Join(basePath, "funcs_EPX.gen"))
	if err != nil {
		panic(err)
	}

	tmpl, err := template.New("ep").Funcs(TemplateFuncs).Parse(string(templateCode))
	if err != nil {
		panic(err)
	}

	result := ""
	for inputs := 1; inputs <= maxX; inputs++ {
		data := struct {
			Inputs  int
			Outputs int
		}{
			Inputs:  inputs,
			Outputs: 0,
		}

		var buf bytes.Buffer
		err := tmpl.ExecuteTemplate(&buf, "EPx", data)
		if err != nil {
			panic(err)
		}

		result += buf.String() + "\n"
	}

	return result
}

func generateXY(basePath string, maxX, maxY int) string {
	templateCode, err := os.ReadFile(path.Join(basePath, "funcs_EPXY.gen"))
	if err != nil {
		panic(err)
	}

	tmpl, err := template.New("EP").Funcs(TemplateFuncs).Parse(string(templateCode))
	if err != nil {
		panic(err)
	}

	result := ""
	for inputs := 1; inputs <= maxX; inputs++ {
		for outputs := 0; outputs <= maxY; outputs++ {
			data := struct {
				Inputs  int
				Outputs int
			}{
				Inputs:  inputs,
				Outputs: outputs,
			}

			var buf bytes.Buffer
			err := tmpl.ExecuteTemplate(&buf, "EPxy", data)
			if err != nil {
				panic(err)
			}

			result += buf.String() + "\n"
		}
	}

	return result
}

func generate0Y(basePath string, maxY int) string {
	result := ""

	templateCode, err := os.ReadFile(path.Join(basePath, "funcs_EP0Y.gen"))
	if err != nil {
		panic(err)
	}

	tmpl, err := template.New("EP").Funcs(TemplateFuncs).Parse(string(templateCode))
	if err != nil {
		panic(err)
	}
	for outputs := 1; outputs <= 10; outputs++ {
		data := struct {
			Outputs int
			Inputs  int
		}{
			Inputs:  0,
			Outputs: outputs,
		}

		var buf bytes.Buffer
		err := tmpl.ExecuteTemplate(&buf, "EP0Y", data)
		if err != nil {
			panic(err)
		}

		result += buf.String()
	}

	return result
}

func main() {
	fmt.Println("Generating Entrypoint functions [Start]")
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		panic("unable to get the current cwd")
	}
	basePath := filepath.Dir(filename)

	result := `// Code generated by generate_entrypoints. DO NOT EDIT.
// If changes to the code are required, modify 'funcs_EPXY.gen' or 'funcs_EPX.gen'
// nolint:all

package coreutil

import (
	"github.com/iotaledger/wasp/v2/packages/isc"
	"fmt"
)

	`

	result += generateX(basePath, 5)
	result += generate0Y(basePath, 5)
	result += generateXY(basePath, 5, 5)

	file, err := os.Create(path.Join(basePath, "../generated_entrypoints.go"))
	if err != nil {
		panic(err)
	}
	defer file.Close()

	formattedCode, err := format.Source([]byte(result))
	if err != nil {
		panic(err)
	}

	_, err = file.Write(formattedCode)
	if err != nil {
		panic(err)
	}

	fmt.Println("Generating Entrypoint functions [Done]")
}
