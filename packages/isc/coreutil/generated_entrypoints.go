// Code generated by generate_entrypoints. DO NOT EDIT.
// If changes to the code are required, modify 'funcs_EPXY.gen' or 'funcs_EPX.gen'
// nolint:all

package coreutil

import (
	"fmt"
	"github.com/iotaledger/wasp/v2/packages/isc"
)

// EP1 is a utility type for entry points that receive 1 parameter(s)
type EP1[S isc.SandboxBase, T1 any, I1 CallArgsCodec[T1]] struct {
	EntryPointInfo[S]
	Input1 I1
}

func NewEP1[T1 any, I1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	in1 I1,
) EP1[isc.Sandbox, T1, I1] {
	return EP1[isc.Sandbox, T1, I1]{
		EntryPointInfo: contract.Func(name),
		Input1:         in1,
	}
}

func NewViewEP1[T1 any, I1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	in1 I1,
) EP1[isc.SandboxView, T1, I1] {
	return EP1[isc.SandboxView, T1, I1]{
		EntryPointInfo: contract.ViewFunc(name),
		Input1:         in1,
	}
}

func (e EP1[S, T1, I1]) WithHandler(f func(ctx S, p1 T1)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		f(ctx, p1)
		return isc.NewCallArguments()
	})
}

func (e EP1[S, T1, I1]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP1[S, T1, I1]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return err
}

func (e EP1[S, T1, I1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP1[S, T1, I1]) Outputs() []FieldArg {
	return make([]FieldArg, 0)
}

// EP2 is a utility type for entry points that receive 2 parameter(s)
type EP2[S isc.SandboxBase, T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]] struct {
	EntryPointInfo[S]
	Input1 I1
	Input2 I2
}

func NewEP2[T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2,
) EP2[isc.Sandbox, T1, T2, I1, I2] {
	return EP2[isc.Sandbox, T1, T2, I1, I2]{
		EntryPointInfo: contract.Func(name),
		Input1:         in1,
		Input2:         in2,
	}
}

func NewViewEP2[T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2,
) EP2[isc.SandboxView, T1, T2, I1, I2] {
	return EP2[isc.SandboxView, T1, T2, I1, I2]{
		EntryPointInfo: contract.ViewFunc(name),
		Input1:         in1,
		Input2:         in2,
	}
}

func (e EP2[S, T1, T2, I1, I2]) WithHandler(f func(ctx S, p1 T1, p2 T2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		f(ctx, p1, p2)
		return isc.NewCallArguments()
	})
}

func (e EP2[S, T1, T2, I1, I2]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP2[S, T1, T2, I1, I2]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return err
}

func (e EP2[S, T1, T2, I1, I2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP2[S, T1, T2, I1, I2]) Outputs() []FieldArg {
	return make([]FieldArg, 0)
}

// EP3 is a utility type for entry points that receive 3 parameter(s)
type EP3[S isc.SandboxBase, T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]] struct {
	EntryPointInfo[S]
	Input1 I1
	Input2 I2
	Input3 I3
}

func NewEP3[T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3,
) EP3[isc.Sandbox, T1, T2, T3, I1, I2, I3] {
	return EP3[isc.Sandbox, T1, T2, T3, I1, I2, I3]{
		EntryPointInfo: contract.Func(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
	}
}

func NewViewEP3[T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3,
) EP3[isc.SandboxView, T1, T2, T3, I1, I2, I3] {
	return EP3[isc.SandboxView, T1, T2, T3, I1, I2, I3]{
		EntryPointInfo: contract.ViewFunc(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
	}
}

func (e EP3[S, T1, T2, T3, I1, I2, I3]) WithHandler(f func(ctx S, p1 T1, p2 T2, p3 T3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3)
		return isc.NewCallArguments()
	})
}

func (e EP3[S, T1, T2, T3, I1, I2, I3]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP3[S, T1, T2, T3, I1, I2, I3]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return err
}

func (e EP3[S, T1, T2, T3, I1, I2, I3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP3[S, T1, T2, T3, I1, I2, I3]) Outputs() []FieldArg {
	return make([]FieldArg, 0)
}

// EP4 is a utility type for entry points that receive 4 parameter(s)
type EP4[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]] struct {
	EntryPointInfo[S]
	Input1 I1
	Input2 I2
	Input3 I3
	Input4 I4
}

func NewEP4[T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3, in4 I4,
) EP4[isc.Sandbox, T1, T2, T3, T4, I1, I2, I3, I4] {
	return EP4[isc.Sandbox, T1, T2, T3, T4, I1, I2, I3, I4]{
		EntryPointInfo: contract.Func(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
		Input4:         in4,
	}
}

func NewViewEP4[T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3, in4 I4,
) EP4[isc.SandboxView, T1, T2, T3, T4, I1, I2, I3, I4] {
	return EP4[isc.SandboxView, T1, T2, T3, T4, I1, I2, I3, I4]{
		EntryPointInfo: contract.ViewFunc(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
		Input4:         in4,
	}
}

func (e EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]) WithHandler(f func(ctx S, p1 T1, p2 T2, p3 T3, p4 T4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3, p4)
		return isc.NewCallArguments()
	})
}

func (e EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return err
}

func (e EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]) Outputs() []FieldArg {
	return make([]FieldArg, 0)
}

// EP5 is a utility type for entry points that receive 5 parameter(s)
type EP5[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]] struct {
	EntryPointInfo[S]
	Input1 I1
	Input2 I2
	Input3 I3
	Input4 I4
	Input5 I5
}

func NewEP5[T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3, in4 I4, in5 I5,
) EP5[isc.Sandbox, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5] {
	return EP5[isc.Sandbox, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]{
		EntryPointInfo: contract.Func(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
		Input4:         in4,
		Input5:         in5,
	}
}

func NewViewEP5[T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	in1 I1, in2 I2, in3 I3, in4 I4, in5 I5,
) EP5[isc.SandboxView, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5] {
	return EP5[isc.SandboxView, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]{
		EntryPointInfo: contract.ViewFunc(name),
		Input1:         in1,
		Input2:         in2,
		Input3:         in3,
		Input4:         in4,
		Input5:         in5,
	}
}

func (e EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) WithHandler(f func(ctx S, p1 T1, p2 T2, p3 T3, p4 T4, p5 T5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3, p4, p5)
		return isc.NewCallArguments()
	})
}

func (e EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return err
}

func (e EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Outputs() []FieldArg {
	return make([]FieldArg, 0)
}

// EP01 is a utility type for entry points that receive 0 parameters and return 1 value(s)
type EP01[S isc.SandboxBase, T1 any, O1 CallArgsCodec[T1]] struct {
	EP0[S]
	Output1 O1
}

func NewEP01[T1 any, O1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	out1 O1,
) EP01[isc.Sandbox, T1, O1] {
	return EP01[isc.Sandbox, T1, O1]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
	}
}

func NewViewEP01[T1 any, O1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	out1 O1,
) EP01[isc.SandboxView, T1, O1] {
	return EP01[isc.SandboxView, T1, O1]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
	}
}

func (e EP01[S, T1, O1]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP01[S, T1, O1]) WithHandler(f func(S) T1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1 := f(ctx)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP01[S, T1, O1]) DecodeOutput(arguments isc.CallArguments) (T1, error) {
	var err error
	var o1 T1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP01[S, T1, O1]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, error) {
	var o1 T1

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP01[S, T1, O1]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP01[S, T1, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP02 is a utility type for entry points that receive 0 parameters and return 2 value(s)
type EP02[S isc.SandboxBase, T1 any, T2 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
}

func NewEP02[T1 any, T2 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2,
) EP02[isc.Sandbox, T1, T2, O1, O2] {
	return EP02[isc.Sandbox, T1, T2, O1, O2]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP02[T1 any, T2 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2,
) EP02[isc.SandboxView, T1, T2, O1, O2] {
	return EP02[isc.SandboxView, T1, T2, O1, O2]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP02[S, T1, T2, O1, O2]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP02[S, T1, T2, O1, O2]) WithHandler(f func(S) (T1, T2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP02[S, T1, T2, O1, O2]) DecodeOutput(arguments isc.CallArguments) (T1, T2, error) {
	var err error
	var o1 T1
	var o2 T2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP02[S, T1, T2, O1, O2]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, error) {
	var o1 T1
	var o2 T2

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP02[S, T1, T2, O1, O2]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP02[S, T1, T2, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP03 is a utility type for entry points that receive 0 parameters and return 3 value(s)
type EP03[S isc.SandboxBase, T1 any, T2 any, T3 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP03[T1 any, T2 any, T3 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3,
) EP03[isc.Sandbox, T1, T2, T3, O1, O2, O3] {
	return EP03[isc.Sandbox, T1, T2, T3, O1, O2, O3]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP03[T1 any, T2 any, T3 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3,
) EP03[isc.SandboxView, T1, T2, T3, O1, O2, O3] {
	return EP03[isc.SandboxView, T1, T2, T3, O1, O2, O3]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) WithHandler(f func(S) (T1, T2, T3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, error) {
	var o1 T1
	var o2 T2
	var o3 T3

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP03[S, T1, T2, T3, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP04 is a utility type for entry points that receive 0 parameters and return 4 value(s)
type EP04[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP04[T1 any, T2 any, T3 any, T4 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP04[isc.Sandbox, T1, T2, T3, T4, O1, O2, O3, O4] {
	return EP04[isc.Sandbox, T1, T2, T3, T4, O1, O2, O3, O4]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP04[T1 any, T2 any, T3 any, T4 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP04[isc.SandboxView, T1, T2, T3, T4, O1, O2, O3, O4] {
	return EP04[isc.SandboxView, T1, T2, T3, T4, O1, O2, O3, O4]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) WithHandler(f func(S) (T1, T2, T3, T4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP04[S, T1, T2, T3, T4, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP05 is a utility type for entry points that receive 0 parameters and return 5 value(s)
type EP05[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP05[T1 any, T2 any, T3 any, T4 any, T5 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP05[isc.Sandbox, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5] {
	return EP05[isc.Sandbox, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP05[T1 any, T2 any, T3 any, T4 any, T5 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP05[isc.SandboxView, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5] {
	return EP05[isc.SandboxView, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) WithHandler(f func(S) (T1, T2, T3, T4, T5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP05[S, T1, T2, T3, T4, T5, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}

// EP06 is a utility type for entry points that receive 0 parameters and return 6 value(s)
type EP06[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
	Output6 O6
}

func NewEP06[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6,
) EP06[isc.Sandbox, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6] {
	return EP06[isc.Sandbox, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
	}
}

func NewViewEP06[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6,
) EP06[isc.SandboxView, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6] {
	return EP06[isc.SandboxView, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
	}
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) WithHandler(f func(S) (T1, T2, T3, T4, T5, T6)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5, r6 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)
		output6 := e.Output6.Encode(r6)

		return isc.NewCallArguments(output1, output2, output3, output4, output5, output6)

	})
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, T6, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	i6, err := arguments.At(5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	o6, err = e.Output6.Decode(i6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	return o1, o2, o3, o4, o5, o6, nil
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, T6, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, err
	}

	return e.DecodeOutput(res)
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP06[S, T1, T2, T3, T4, T5, T6, O1, O2, O3, O4, O5, O6]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)
	outputs = append(outputs, e.Output6)

	return outputs
}

// EP07 is a utility type for entry points that receive 0 parameters and return 7 value(s)
type EP07[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
	Output6 O6
	Output7 O7
}

func NewEP07[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7,
) EP07[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7] {
	return EP07[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
	}
}

func NewViewEP07[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7,
) EP07[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7] {
	return EP07[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
	}
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) WithHandler(f func(S) (T1, T2, T3, T4, T5, T6, T7)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5, r6, r7 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)
		output6 := e.Output6.Encode(r6)
		output7 := e.Output7.Encode(r7)

		return isc.NewCallArguments(output1, output2, output3, output4, output5, output6, output7)

	})
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, T6, T7, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i6, err := arguments.At(5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o6, err = e.Output6.Decode(i6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	i7, err := arguments.At(6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	o7, err = e.Output7.Decode(i7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	return o1, o2, o3, o4, o5, o6, o7, nil
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, T6, T7, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, err
	}

	return e.DecodeOutput(res)
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP07[S, T1, T2, T3, T4, T5, T6, T7, O1, O2, O3, O4, O5, O6, O7]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)
	outputs = append(outputs, e.Output6)
	outputs = append(outputs, e.Output7)

	return outputs
}

// EP08 is a utility type for entry points that receive 0 parameters and return 8 value(s)
type EP08[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
	Output6 O6
	Output7 O7
	Output8 O8
}

func NewEP08[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8,
) EP08[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8] {
	return EP08[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
		Output8: out8,
	}
}

func NewViewEP08[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8,
) EP08[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8] {
	return EP08[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
		Output8: out8,
	}
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) WithHandler(f func(S) (T1, T2, T3, T4, T5, T6, T7, T8)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5, r6, r7, r8 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)
		output6 := e.Output6.Encode(r6)
		output7 := e.Output7.Encode(r7)
		output8 := e.Output8.Encode(r8)

		return isc.NewCallArguments(output1, output2, output3, output4, output5, output6, output7, output8)

	})
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, T6, T7, T8, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i6, err := arguments.At(5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o6, err = e.Output6.Decode(i6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i7, err := arguments.At(6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o7, err = e.Output7.Decode(i7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	i8, err := arguments.At(7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	o8, err = e.Output8.Decode(i8)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	return o1, o2, o3, o4, o5, o6, o7, o8, nil
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, T6, T7, T8, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, err
	}

	return e.DecodeOutput(res)
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP08[S, T1, T2, T3, T4, T5, T6, T7, T8, O1, O2, O3, O4, O5, O6, O7, O8]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)
	outputs = append(outputs, e.Output6)
	outputs = append(outputs, e.Output7)
	outputs = append(outputs, e.Output8)

	return outputs
}

// EP09 is a utility type for entry points that receive 0 parameters and return 9 value(s)
type EP09[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9]] struct {
	EP0[S]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
	Output6 O6
	Output7 O7
	Output8 O8
	Output9 O9
}

func NewEP09[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8, out9 O9,
) EP09[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9] {
	return EP09[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]{
		EP0:     NewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
		Output8: out8,
		Output9: out9,
	}
}

func NewViewEP09[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8, out9 O9,
) EP09[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9] {
	return EP09[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]{
		EP0:     NewViewEP0(contract, name),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
		Output6: out6,
		Output7: out7,
		Output8: out8,
		Output9: out9,
	}
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) WithHandler(f func(S) (T1, T2, T3, T4, T5, T6, T7, T8, T9)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5, r6, r7, r8, r9 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)
		output6 := e.Output6.Encode(r6)
		output7 := e.Output7.Encode(r7)
		output8 := e.Output8.Encode(r8)
		output9 := e.Output9.Encode(r9)

		return isc.NewCallArguments(output1, output2, output3, output4, output5, output6, output7, output8, output9)

	})
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, T6, T7, T8, T9, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8
	var o9 T9

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i6, err := arguments.At(5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o6, err = e.Output6.Decode(i6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i7, err := arguments.At(6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o7, err = e.Output7.Decode(i7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i8, err := arguments.At(7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o8, err = e.Output8.Decode(i8)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	i9, err := arguments.At(8)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	o9, err = e.Output9.Decode(i9)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	return o1, o2, o3, o4, o5, o6, o7, o8, o9, nil
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, T6, T7, T8, T9, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8
	var o9 T9

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, err
	}

	return e.DecodeOutput(res)
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP09[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, O1, O2, O3, O4, O5, O6, O7, O8, O9]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)
	outputs = append(outputs, e.Output6)
	outputs = append(outputs, e.Output7)
	outputs = append(outputs, e.Output8)
	outputs = append(outputs, e.Output9)

	return outputs
}

// EP010 is a utility type for entry points that receive 0 parameters and return 10 value(s)
type EP010[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9], O10 CallArgsCodec[T10]] struct {
	EP0[S]
	Output1  O1
	Output2  O2
	Output3  O3
	Output4  O4
	Output5  O5
	Output6  O6
	Output7  O7
	Output8  O8
	Output9  O9
	Output10 O10
}

func NewEP010[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9], O10 CallArgsCodec[T10]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8, out9 O9, out10 O10,
) EP010[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10] {
	return EP010[isc.Sandbox, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]{
		EP0:      NewEP0(contract, name),
		Output1:  out1,
		Output2:  out2,
		Output3:  out3,
		Output4:  out4,
		Output5:  out5,
		Output6:  out6,
		Output7:  out7,
		Output8:  out8,
		Output9:  out9,
		Output10: out10,
	}
}

func NewViewEP010[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, O1 CallArgsCodec[T1], O2 CallArgsCodec[T2], O3 CallArgsCodec[T3], O4 CallArgsCodec[T4], O5 CallArgsCodec[T5], O6 CallArgsCodec[T6], O7 CallArgsCodec[T7], O8 CallArgsCodec[T8], O9 CallArgsCodec[T9], O10 CallArgsCodec[T10]](
	contract *ContractInfo, name string,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5, out6 O6, out7 O7, out8 O8, out9 O9, out10 O10,
) EP010[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10] {
	return EP010[isc.SandboxView, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]{
		EP0:      NewViewEP0(contract, name),
		Output1:  out1,
		Output2:  out2,
		Output3:  out3,
		Output4:  out4,
		Output5:  out5,
		Output6:  out6,
		Output7:  out7,
		Output8:  out8,
		Output9:  out9,
		Output10: out10,
	}
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) Message() isc.Message {
	callArgs := isc.NewCallArguments()
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) WithHandler(f func(S) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {

		r1, r2, r3, r4, r5, r6, r7, r8, r9, r10 := f(ctx)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)
		output6 := e.Output6.Encode(r6)
		output7 := e.Output7.Encode(r7)
		output8 := e.Output8.Encode(r8)
		output9 := e.Output9.Encode(r9)
		output10 := e.Output10.Encode(r10)

		return isc.NewCallArguments(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10)

	})
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) DecodeOutput(arguments isc.CallArguments) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, error) {
	var err error
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8
	var o9 T9
	var o10 T10

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i6, err := arguments.At(5)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o6, err = e.Output6.Decode(i6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i7, err := arguments.At(6)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o7, err = e.Output7.Decode(i7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i8, err := arguments.At(7)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o8, err = e.Output8.Decode(i8)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i9, err := arguments.At(8)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o9, err = e.Output9.Decode(i9)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	i10, err := arguments.At(9)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	o10, err = e.Output10.Decode(i10)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, nil
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) Call(
	send func(msg isc.Message) (isc.CallArguments, error),
) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, error) {
	var o1 T1
	var o2 T2
	var o3 T3
	var o4 T4
	var o5 T5
	var o6 T6
	var o7 T7
	var o8 T8
	var o9 T9
	var o10 T10

	msg := e.Message()
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, err
	}

	return e.DecodeOutput(res)
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) Inputs() []FieldArg {
	return make([]FieldArg, 0)
}

func (e EP010[S, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)
	outputs = append(outputs, e.Output6)
	outputs = append(outputs, e.Output7)
	outputs = append(outputs, e.Output8)
	outputs = append(outputs, e.Output9)
	outputs = append(outputs, e.Output10)

	return outputs
}

// EP10 is a utility type for entry points that receive 1 parameters and return 0 value(s)
type EP10[S isc.SandboxBase, T1 any, I1 CallArgsCodec[T1]] struct {
	EP1[S, T1, I1]
}

func NewEP10[T1 any, I1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	in1 I1,

) EP10[isc.Sandbox, T1, I1] {
	return EP10[isc.Sandbox, T1, I1]{
		EP1: NewEP1(contract, name, in1),
	}
}

func NewViewEP10[T1 any, I1 CallArgsCodec[T1]](
	contract *ContractInfo, name string,
	in1 I1,

) EP10[isc.SandboxView, T1, I1] {
	return EP10[isc.SandboxView, T1, I1]{
		EP1: NewViewEP1(contract, name, in1),
	}
}

func (e EP10[S, T1, I1]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP10[S, T1, I1]) WithHandler(f func(S, T1)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		f(ctx, p1)
		return isc.NewCallArguments()

	})
}

func (e EP10[S, T1, I1]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return nil
}

func (e EP10[S, T1, I1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP10[S, T1, I1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	return outputs
}

// EP11 is a utility type for entry points that receive 1 parameters and return 1 value(s)
type EP11[S isc.SandboxBase, T1 any, R1 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1]] struct {
	EP1[S, T1, I1]
	Output1 O1
}

func NewEP11[T1 any, R1 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1,
) EP11[isc.Sandbox, T1, R1, I1, O1] {
	return EP11[isc.Sandbox, T1, R1, I1, O1]{
		EP1:     NewEP1(contract, name, in1),
		Output1: out1,
	}
}

func NewViewEP11[T1 any, R1 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1,
) EP11[isc.SandboxView, T1, R1, I1, O1] {
	return EP11[isc.SandboxView, T1, R1, I1, O1]{
		EP1:     NewViewEP1(contract, name, in1),
		Output1: out1,
	}
}

func (e EP11[S, T1, R1, I1, O1]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP11[S, T1, R1, I1, O1]) WithHandler(f func(S, T1) R1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		r1 := f(ctx, p1)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP11[S, T1, R1, I1, O1]) DecodeOutput(arguments isc.CallArguments) (R1, error) {
	var err error
	var o1 R1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP11[S, T1, R1, I1, O1]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, error) {
	var o1 R1

	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP11[S, T1, R1, I1, O1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP11[S, T1, R1, I1, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP12 is a utility type for entry points that receive 1 parameters and return 2 value(s)
type EP12[S isc.SandboxBase, T1 any, R1 any, R2 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]] struct {
	EP1[S, T1, I1]
	Output1 O1
	Output2 O2
}

func NewEP12[T1 any, R1 any, R2 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2,
) EP12[isc.Sandbox, T1, R1, R2, I1, O1, O2] {
	return EP12[isc.Sandbox, T1, R1, R2, I1, O1, O2]{
		EP1:     NewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP12[T1 any, R1 any, R2 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2,
) EP12[isc.SandboxView, T1, R1, R2, I1, O1, O2] {
	return EP12[isc.SandboxView, T1, R1, R2, I1, O1, O2]{
		EP1:     NewViewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) WithHandler(f func(S, T1) (R1, R2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		r1, r2 := f(ctx, p1)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) DecodeOutput(arguments isc.CallArguments) (R1, R2, error) {
	var err error
	var o1 R1
	var o2 R2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, error) {
	var o1 R1
	var o2 R2

	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP12[S, T1, R1, R2, I1, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP13 is a utility type for entry points that receive 1 parameters and return 3 value(s)
type EP13[S isc.SandboxBase, T1 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]] struct {
	EP1[S, T1, I1]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP13[T1 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3,
) EP13[isc.Sandbox, T1, R1, R2, R3, I1, O1, O2, O3] {
	return EP13[isc.Sandbox, T1, R1, R2, R3, I1, O1, O2, O3]{
		EP1:     NewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP13[T1 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3,
) EP13[isc.SandboxView, T1, R1, R2, R3, I1, O1, O2, O3] {
	return EP13[isc.SandboxView, T1, R1, R2, R3, I1, O1, O2, O3]{
		EP1:     NewViewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) WithHandler(f func(S, T1) (R1, R2, R3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		r1, r2, r3 := f(ctx, p1)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, error) {
	var o1 R1
	var o2 R2
	var o3 R3

	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP13[S, T1, R1, R2, R3, I1, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP14 is a utility type for entry points that receive 1 parameters and return 4 value(s)
type EP14[S isc.SandboxBase, T1 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]] struct {
	EP1[S, T1, I1]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP14[T1 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP14[isc.Sandbox, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4] {
	return EP14[isc.Sandbox, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]{
		EP1:     NewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP14[T1 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP14[isc.SandboxView, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4] {
	return EP14[isc.SandboxView, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]{
		EP1:     NewViewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) WithHandler(f func(S, T1) (R1, R2, R3, R4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		r1, r2, r3, r4 := f(ctx, p1)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP14[S, T1, R1, R2, R3, R4, I1, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP15 is a utility type for entry points that receive 1 parameters and return 5 value(s)
type EP15[S isc.SandboxBase, T1 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]] struct {
	EP1[S, T1, I1]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP15[T1 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP15[isc.Sandbox, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5] {
	return EP15[isc.Sandbox, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]{
		EP1:     NewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP15[T1 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP15[isc.SandboxView, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5] {
	return EP15[isc.SandboxView, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]{
		EP1:     NewViewEP1(contract, name, in1),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) Message(p1 T1) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) WithHandler(f func(S, T1) (R1, R2, R3, R4, R5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)

		r1, r2, r3, r4, r5 := f(ctx, p1)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, R5, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) Call(
	p1 T1,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, R5, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	msg := e.Message(p1)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)

	return inputs
}

func (e EP15[S, T1, R1, R2, R3, R4, R5, I1, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}

// EP20 is a utility type for entry points that receive 2 parameters and return 0 value(s)
type EP20[S isc.SandboxBase, T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]] struct {
	EP2[S, T1, T2, I1, I2]
}

func NewEP20[T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,

) EP20[isc.Sandbox, T1, T2, I1, I2] {
	return EP20[isc.Sandbox, T1, T2, I1, I2]{
		EP2: NewEP2(contract, name, in1, in2),
	}
}

func NewViewEP20[T1 any, T2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,

) EP20[isc.SandboxView, T1, T2, I1, I2] {
	return EP20[isc.SandboxView, T1, T2, I1, I2]{
		EP2: NewViewEP2(contract, name, in1, in2),
	}
}

func (e EP20[S, T1, T2, I1, I2]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP20[S, T1, T2, I1, I2]) WithHandler(f func(S, T1, T2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		f(ctx, p1, p2)
		return isc.NewCallArguments()

	})
}

func (e EP20[S, T1, T2, I1, I2]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return nil
}

func (e EP20[S, T1, T2, I1, I2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP20[S, T1, T2, I1, I2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	return outputs
}

// EP21 is a utility type for entry points that receive 2 parameters and return 1 value(s)
type EP21[S isc.SandboxBase, T1 any, T2 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1]] struct {
	EP2[S, T1, T2, I1, I2]
	Output1 O1
}

func NewEP21[T1 any, T2 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1,
) EP21[isc.Sandbox, T1, T2, R1, I1, I2, O1] {
	return EP21[isc.Sandbox, T1, T2, R1, I1, I2, O1]{
		EP2:     NewEP2(contract, name, in1, in2),
		Output1: out1,
	}
}

func NewViewEP21[T1 any, T2 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1,
) EP21[isc.SandboxView, T1, T2, R1, I1, I2, O1] {
	return EP21[isc.SandboxView, T1, T2, R1, I1, I2, O1]{
		EP2:     NewViewEP2(contract, name, in1, in2),
		Output1: out1,
	}
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) WithHandler(f func(S, T1, T2) R1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		r1 := f(ctx, p1, p2)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) DecodeOutput(arguments isc.CallArguments) (R1, error) {
	var err error
	var o1 R1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, error) {
	var o1 R1

	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP21[S, T1, T2, R1, I1, I2, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP22 is a utility type for entry points that receive 2 parameters and return 2 value(s)
type EP22[S isc.SandboxBase, T1 any, T2 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]] struct {
	EP2[S, T1, T2, I1, I2]
	Output1 O1
	Output2 O2
}

func NewEP22[T1 any, T2 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2,
) EP22[isc.Sandbox, T1, T2, R1, R2, I1, I2, O1, O2] {
	return EP22[isc.Sandbox, T1, T2, R1, R2, I1, I2, O1, O2]{
		EP2:     NewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP22[T1 any, T2 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2,
) EP22[isc.SandboxView, T1, T2, R1, R2, I1, I2, O1, O2] {
	return EP22[isc.SandboxView, T1, T2, R1, R2, I1, I2, O1, O2]{
		EP2:     NewViewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) WithHandler(f func(S, T1, T2) (R1, R2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		r1, r2 := f(ctx, p1, p2)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) DecodeOutput(arguments isc.CallArguments) (R1, R2, error) {
	var err error
	var o1 R1
	var o2 R2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, error) {
	var o1 R1
	var o2 R2

	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP22[S, T1, T2, R1, R2, I1, I2, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP23 is a utility type for entry points that receive 2 parameters and return 3 value(s)
type EP23[S isc.SandboxBase, T1 any, T2 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]] struct {
	EP2[S, T1, T2, I1, I2]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP23[T1 any, T2 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3,
) EP23[isc.Sandbox, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3] {
	return EP23[isc.Sandbox, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]{
		EP2:     NewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP23[T1 any, T2 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3,
) EP23[isc.SandboxView, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3] {
	return EP23[isc.SandboxView, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]{
		EP2:     NewViewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) WithHandler(f func(S, T1, T2) (R1, R2, R3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		r1, r2, r3 := f(ctx, p1, p2)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, error) {
	var o1 R1
	var o2 R2
	var o3 R3

	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP23[S, T1, T2, R1, R2, R3, I1, I2, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP24 is a utility type for entry points that receive 2 parameters and return 4 value(s)
type EP24[S isc.SandboxBase, T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]] struct {
	EP2[S, T1, T2, I1, I2]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP24[T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP24[isc.Sandbox, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4] {
	return EP24[isc.Sandbox, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]{
		EP2:     NewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP24[T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP24[isc.SandboxView, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4] {
	return EP24[isc.SandboxView, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]{
		EP2:     NewViewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) WithHandler(f func(S, T1, T2) (R1, R2, R3, R4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		r1, r2, r3, r4 := f(ctx, p1, p2)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP24[S, T1, T2, R1, R2, R3, R4, I1, I2, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP25 is a utility type for entry points that receive 2 parameters and return 5 value(s)
type EP25[S isc.SandboxBase, T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]] struct {
	EP2[S, T1, T2, I1, I2]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP25[T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP25[isc.Sandbox, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5] {
	return EP25[isc.Sandbox, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]{
		EP2:     NewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP25[T1 any, T2 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP25[isc.SandboxView, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5] {
	return EP25[isc.SandboxView, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]{
		EP2:     NewViewEP2(contract, name, in1, in2),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) Message(p1 T1, p2 T2) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) WithHandler(f func(S, T1, T2) (R1, R2, R3, R4, R5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)

		r1, r2, r3, r4, r5 := f(ctx, p1, p2)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, R5, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) Call(
	p1 T1, p2 T2,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, R5, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	msg := e.Message(p1, p2)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)

	return inputs
}

func (e EP25[S, T1, T2, R1, R2, R3, R4, R5, I1, I2, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}

// EP30 is a utility type for entry points that receive 3 parameters and return 0 value(s)
type EP30[S isc.SandboxBase, T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
}

func NewEP30[T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,

) EP30[isc.Sandbox, T1, T2, T3, I1, I2, I3] {
	return EP30[isc.Sandbox, T1, T2, T3, I1, I2, I3]{
		EP3: NewEP3(contract, name, in1, in2, in3),
	}
}

func NewViewEP30[T1 any, T2 any, T3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,

) EP30[isc.SandboxView, T1, T2, T3, I1, I2, I3] {
	return EP30[isc.SandboxView, T1, T2, T3, I1, I2, I3]{
		EP3: NewViewEP3(contract, name, in1, in2, in3),
	}
}

func (e EP30[S, T1, T2, T3, I1, I2, I3]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP30[S, T1, T2, T3, I1, I2, I3]) WithHandler(f func(S, T1, T2, T3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3)
		return isc.NewCallArguments()

	})
}

func (e EP30[S, T1, T2, T3, I1, I2, I3]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return nil
}

func (e EP30[S, T1, T2, T3, I1, I2, I3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP30[S, T1, T2, T3, I1, I2, I3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	return outputs
}

// EP31 is a utility type for entry points that receive 3 parameters and return 1 value(s)
type EP31[S isc.SandboxBase, T1 any, T2 any, T3 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
	Output1 O1
}

func NewEP31[T1 any, T2 any, T3 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1,
) EP31[isc.Sandbox, T1, T2, T3, R1, I1, I2, I3, O1] {
	return EP31[isc.Sandbox, T1, T2, T3, R1, I1, I2, I3, O1]{
		EP3:     NewEP3(contract, name, in1, in2, in3),
		Output1: out1,
	}
}

func NewViewEP31[T1 any, T2 any, T3 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1,
) EP31[isc.SandboxView, T1, T2, T3, R1, I1, I2, I3, O1] {
	return EP31[isc.SandboxView, T1, T2, T3, R1, I1, I2, I3, O1]{
		EP3:     NewViewEP3(contract, name, in1, in2, in3),
		Output1: out1,
	}
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) WithHandler(f func(S, T1, T2, T3) R1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		r1 := f(ctx, p1, p2, p3)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) DecodeOutput(arguments isc.CallArguments) (R1, error) {
	var err error
	var o1 R1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, error) {
	var o1 R1

	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP31[S, T1, T2, T3, R1, I1, I2, I3, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP32 is a utility type for entry points that receive 3 parameters and return 2 value(s)
type EP32[S isc.SandboxBase, T1 any, T2 any, T3 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
	Output1 O1
	Output2 O2
}

func NewEP32[T1 any, T2 any, T3 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2,
) EP32[isc.Sandbox, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2] {
	return EP32[isc.Sandbox, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]{
		EP3:     NewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP32[T1 any, T2 any, T3 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2,
) EP32[isc.SandboxView, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2] {
	return EP32[isc.SandboxView, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]{
		EP3:     NewViewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) WithHandler(f func(S, T1, T2, T3) (R1, R2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		r1, r2 := f(ctx, p1, p2, p3)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) DecodeOutput(arguments isc.CallArguments) (R1, R2, error) {
	var err error
	var o1 R1
	var o2 R2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, error) {
	var o1 R1
	var o2 R2

	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP32[S, T1, T2, T3, R1, R2, I1, I2, I3, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP33 is a utility type for entry points that receive 3 parameters and return 3 value(s)
type EP33[S isc.SandboxBase, T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP33[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3,
) EP33[isc.Sandbox, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3] {
	return EP33[isc.Sandbox, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]{
		EP3:     NewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP33[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3,
) EP33[isc.SandboxView, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3] {
	return EP33[isc.SandboxView, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]{
		EP3:     NewViewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) WithHandler(f func(S, T1, T2, T3) (R1, R2, R3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		r1, r2, r3 := f(ctx, p1, p2, p3)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, error) {
	var o1 R1
	var o2 R2
	var o3 R3

	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP33[S, T1, T2, T3, R1, R2, R3, I1, I2, I3, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP34 is a utility type for entry points that receive 3 parameters and return 4 value(s)
type EP34[S isc.SandboxBase, T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP34[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP34[isc.Sandbox, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4] {
	return EP34[isc.Sandbox, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]{
		EP3:     NewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP34[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP34[isc.SandboxView, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4] {
	return EP34[isc.SandboxView, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]{
		EP3:     NewViewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) WithHandler(f func(S, T1, T2, T3) (R1, R2, R3, R4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		r1, r2, r3, r4 := f(ctx, p1, p2, p3)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP34[S, T1, T2, T3, R1, R2, R3, R4, I1, I2, I3, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP35 is a utility type for entry points that receive 3 parameters and return 5 value(s)
type EP35[S isc.SandboxBase, T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]] struct {
	EP3[S, T1, T2, T3, I1, I2, I3]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP35[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP35[isc.Sandbox, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5] {
	return EP35[isc.Sandbox, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]{
		EP3:     NewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP35[T1 any, T2 any, T3 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP35[isc.SandboxView, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5] {
	return EP35[isc.SandboxView, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]{
		EP3:     NewViewEP3(contract, name, in1, in2, in3),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) Message(p1 T1, p2 T2, p3 T3) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) WithHandler(f func(S, T1, T2, T3) (R1, R2, R3, R4, R5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)

		r1, r2, r3, r4, r5 := f(ctx, p1, p2, p3)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, R5, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) Call(
	p1 T1, p2 T2, p3 T3,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, R5, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	msg := e.Message(p1, p2, p3)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)

	return inputs
}

func (e EP35[S, T1, T2, T3, R1, R2, R3, R4, R5, I1, I2, I3, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}

// EP40 is a utility type for entry points that receive 4 parameters and return 0 value(s)
type EP40[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
}

func NewEP40[T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,

) EP40[isc.Sandbox, T1, T2, T3, T4, I1, I2, I3, I4] {
	return EP40[isc.Sandbox, T1, T2, T3, T4, I1, I2, I3, I4]{
		EP4: NewEP4(contract, name, in1, in2, in3, in4),
	}
}

func NewViewEP40[T1 any, T2 any, T3 any, T4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,

) EP40[isc.SandboxView, T1, T2, T3, T4, I1, I2, I3, I4] {
	return EP40[isc.SandboxView, T1, T2, T3, T4, I1, I2, I3, I4]{
		EP4: NewViewEP4(contract, name, in1, in2, in3, in4),
	}
}

func (e EP40[S, T1, T2, T3, T4, I1, I2, I3, I4]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP40[S, T1, T2, T3, T4, I1, I2, I3, I4]) WithHandler(f func(S, T1, T2, T3, T4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3, p4)
		return isc.NewCallArguments()

	})
}

func (e EP40[S, T1, T2, T3, T4, I1, I2, I3, I4]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return nil
}

func (e EP40[S, T1, T2, T3, T4, I1, I2, I3, I4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP40[S, T1, T2, T3, T4, I1, I2, I3, I4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	return outputs
}

// EP41 is a utility type for entry points that receive 4 parameters and return 1 value(s)
type EP41[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
	Output1 O1
}

func NewEP41[T1 any, T2 any, T3 any, T4 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1,
) EP41[isc.Sandbox, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1] {
	return EP41[isc.Sandbox, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]{
		EP4:     NewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
	}
}

func NewViewEP41[T1 any, T2 any, T3 any, T4 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1,
) EP41[isc.SandboxView, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1] {
	return EP41[isc.SandboxView, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]{
		EP4:     NewViewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
	}
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) WithHandler(f func(S, T1, T2, T3, T4) R1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		r1 := f(ctx, p1, p2, p3, p4)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) DecodeOutput(arguments isc.CallArguments) (R1, error) {
	var err error
	var o1 R1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, error) {
	var o1 R1

	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP41[S, T1, T2, T3, T4, R1, I1, I2, I3, I4, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP42 is a utility type for entry points that receive 4 parameters and return 2 value(s)
type EP42[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
	Output1 O1
	Output2 O2
}

func NewEP42[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2,
) EP42[isc.Sandbox, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2] {
	return EP42[isc.Sandbox, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]{
		EP4:     NewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP42[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2,
) EP42[isc.SandboxView, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2] {
	return EP42[isc.SandboxView, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]{
		EP4:     NewViewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) WithHandler(f func(S, T1, T2, T3, T4) (R1, R2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		r1, r2 := f(ctx, p1, p2, p3, p4)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) DecodeOutput(arguments isc.CallArguments) (R1, R2, error) {
	var err error
	var o1 R1
	var o2 R2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, error) {
	var o1 R1
	var o2 R2

	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP42[S, T1, T2, T3, T4, R1, R2, I1, I2, I3, I4, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP43 is a utility type for entry points that receive 4 parameters and return 3 value(s)
type EP43[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP43[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3,
) EP43[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3] {
	return EP43[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]{
		EP4:     NewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP43[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3,
) EP43[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3] {
	return EP43[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]{
		EP4:     NewViewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) WithHandler(f func(S, T1, T2, T3, T4) (R1, R2, R3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		r1, r2, r3 := f(ctx, p1, p2, p3, p4)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, error) {
	var o1 R1
	var o2 R2
	var o3 R3

	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP43[S, T1, T2, T3, T4, R1, R2, R3, I1, I2, I3, I4, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP44 is a utility type for entry points that receive 4 parameters and return 4 value(s)
type EP44[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP44[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP44[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4] {
	return EP44[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]{
		EP4:     NewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP44[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP44[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4] {
	return EP44[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]{
		EP4:     NewViewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) WithHandler(f func(S, T1, T2, T3, T4) (R1, R2, R3, R4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		r1, r2, r3, r4 := f(ctx, p1, p2, p3, p4)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP44[S, T1, T2, T3, T4, R1, R2, R3, R4, I1, I2, I3, I4, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP45 is a utility type for entry points that receive 4 parameters and return 5 value(s)
type EP45[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]] struct {
	EP4[S, T1, T2, T3, T4, I1, I2, I3, I4]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP45[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP45[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5] {
	return EP45[isc.Sandbox, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]{
		EP4:     NewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP45[T1 any, T2 any, T3 any, T4 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP45[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5] {
	return EP45[isc.SandboxView, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]{
		EP4:     NewViewEP4(contract, name, in1, in2, in3, in4),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) Message(p1 T1, p2 T2, p3 T3, p4 T4) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) WithHandler(f func(S, T1, T2, T3, T4) (R1, R2, R3, R4, R5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)

		r1, r2, r3, r4, r5 := f(ctx, p1, p2, p3, p4)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, R5, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, R5, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	msg := e.Message(p1, p2, p3, p4)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)

	return inputs
}

func (e EP45[S, T1, T2, T3, T4, R1, R2, R3, R4, R5, I1, I2, I3, I4, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}

// EP50 is a utility type for entry points that receive 5 parameters and return 0 value(s)
type EP50[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
}

func NewEP50[T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,

) EP50[isc.Sandbox, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5] {
	return EP50[isc.Sandbox, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]{
		EP5: NewEP5(contract, name, in1, in2, in3, in4, in5),
	}
}

func NewViewEP50[T1 any, T2 any, T3 any, T4 any, T5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,

) EP50[isc.SandboxView, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5] {
	return EP50[isc.SandboxView, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]{
		EP5: NewViewEP5(contract, name, in1, in2, in3, in4, in5),
	}
}

func (e EP50[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP50[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) WithHandler(f func(S, T1, T2, T3, T4, T5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		f(ctx, p1, p2, p3, p4, p5)
		return isc.NewCallArguments()

	})
}

func (e EP50[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) error {
	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return err
	}
	if len(res) != 0 {
		return fmt.Errorf("unexpected number of results: expected 0, got %v", len(res))
	}

	return nil
}

func (e EP50[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP50[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	return outputs
}

// EP51 is a utility type for entry points that receive 5 parameters and return 1 value(s)
type EP51[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
	Output1 O1
}

func NewEP51[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1,
) EP51[isc.Sandbox, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1] {
	return EP51[isc.Sandbox, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]{
		EP5:     NewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
	}
}

func NewViewEP51[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1,
) EP51[isc.SandboxView, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1] {
	return EP51[isc.SandboxView, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]{
		EP5:     NewViewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
	}
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) WithHandler(f func(S, T1, T2, T3, T4, T5) R1) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		r1 := f(ctx, p1, p2, p3, p4, p5)
		output1 := e.Output1.Encode(r1)
		return isc.NewCallArguments(output1)

	})
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) DecodeOutput(arguments isc.CallArguments) (R1, error) {
	var err error
	var o1 R1

	i1, err := arguments.At(0)
	if err != nil {
		return o1, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, err
	}

	return o1, nil
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, error) {
	var o1 R1

	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return o1, err
	}

	return e.DecodeOutput(res)
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP51[S, T1, T2, T3, T4, T5, R1, I1, I2, I3, I4, I5, O1]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)

	return outputs
}

// EP52 is a utility type for entry points that receive 5 parameters and return 2 value(s)
type EP52[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
	Output1 O1
	Output2 O2
}

func NewEP52[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2,
) EP52[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2] {
	return EP52[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]{
		EP5:     NewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
	}
}

func NewViewEP52[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2,
) EP52[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2] {
	return EP52[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]{
		EP5:     NewViewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
	}
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) WithHandler(f func(S, T1, T2, T3, T4, T5) (R1, R2)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		r1, r2 := f(ctx, p1, p2, p3, p4, p5)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)

		return isc.NewCallArguments(output1, output2)

	})
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) DecodeOutput(arguments isc.CallArguments) (R1, R2, error) {
	var err error
	var o1 R1
	var o2 R2

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, err
	}

	return o1, o2, nil
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, error) {
	var o1 R1
	var o2 R2

	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return o1, o2, err
	}

	return e.DecodeOutput(res)
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP52[S, T1, T2, T3, T4, T5, R1, R2, I1, I2, I3, I4, I5, O1, O2]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)

	return outputs
}

// EP53 is a utility type for entry points that receive 5 parameters and return 3 value(s)
type EP53[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
	Output1 O1
	Output2 O2
	Output3 O3
}

func NewEP53[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3,
) EP53[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3] {
	return EP53[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]{
		EP5:     NewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func NewViewEP53[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3,
) EP53[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3] {
	return EP53[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]{
		EP5:     NewViewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
	}
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) WithHandler(f func(S, T1, T2, T3, T4, T5) (R1, R2, R3)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		r1, r2, r3 := f(ctx, p1, p2, p3, p4, p5)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)

		return isc.NewCallArguments(output1, output2, output3)

	})
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, err
	}

	return o1, o2, o3, nil
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, error) {
	var o1 R1
	var o2 R2
	var o3 R3

	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, err
	}

	return e.DecodeOutput(res)
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP53[S, T1, T2, T3, T4, T5, R1, R2, R3, I1, I2, I3, I4, I5, O1, O2, O3]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)

	return outputs
}

// EP54 is a utility type for entry points that receive 5 parameters and return 4 value(s)
type EP54[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
}

func NewEP54[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP54[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4] {
	return EP54[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]{
		EP5:     NewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func NewViewEP54[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3, out4 O4,
) EP54[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4] {
	return EP54[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]{
		EP5:     NewViewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
	}
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) WithHandler(f func(S, T1, T2, T3, T4, T5) (R1, R2, R3, R4)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		r1, r2, r3, r4 := f(ctx, p1, p2, p3, p4, p5)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)

		return isc.NewCallArguments(output1, output2, output3, output4)

	})
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return o1, o2, o3, o4, nil
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4

	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, err
	}

	return e.DecodeOutput(res)
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP54[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, I1, I2, I3, I4, I5, O1, O2, O3, O4]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)

	return outputs
}

// EP55 is a utility type for entry points that receive 5 parameters and return 5 value(s)
type EP55[S isc.SandboxBase, T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]] struct {
	EP5[S, T1, T2, T3, T4, T5, I1, I2, I3, I4, I5]
	Output1 O1
	Output2 O2
	Output3 O3
	Output4 O4
	Output5 O5
}

func NewEP55[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP55[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5] {
	return EP55[isc.Sandbox, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]{
		EP5:     NewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func NewViewEP55[T1 any, T2 any, T3 any, T4 any, T5 any, R1 any, R2 any, R3 any, R4 any, R5 any, I1 CallArgsCodec[T1], I2 CallArgsCodec[T2], I3 CallArgsCodec[T3], I4 CallArgsCodec[T4], I5 CallArgsCodec[T5], O1 CallArgsCodec[R1], O2 CallArgsCodec[R2], O3 CallArgsCodec[R3], O4 CallArgsCodec[R4], O5 CallArgsCodec[R5]](
	contract *ContractInfo, name string,
	in1 I1,
	in2 I2,
	in3 I3,
	in4 I4,
	in5 I5,
	out1 O1, out2 O2, out3 O3, out4 O4, out5 O5,
) EP55[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5] {
	return EP55[isc.SandboxView, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]{
		EP5:     NewViewEP5(contract, name, in1, in2, in3, in4, in5),
		Output1: out1,
		Output2: out2,
		Output3: out3,
		Output4: out4,
		Output5: out5,
	}
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) Message(p1 T1, p2 T2, p3 T3, p4 T4, p5 T5) isc.Message {
	callArgs := isc.NewCallArguments(e.Input1.Encode(p1), e.Input2.Encode(p2), e.Input3.Encode(p3), e.Input4.Encode(p4), e.Input5.Encode(p5))
	return e.EntryPointInfo.Message(callArgs)
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) WithHandler(f func(S, T1, T2, T3, T4, T5) (R1, R2, R3, R4, R5)) *EntryPointHandler[S] {
	return e.EntryPointInfo.WithHandler(func(ctx S) isc.CallArguments {
		params := ctx.Params()
		p1, err := e.Input1.Decode(params.MustAt(0))
		ctx.RequireNoError(err)
		p2, err := e.Input2.Decode(params.MustAt(1))
		ctx.RequireNoError(err)
		p3, err := e.Input3.Decode(params.MustAt(2))
		ctx.RequireNoError(err)
		p4, err := e.Input4.Decode(params.MustAt(3))
		ctx.RequireNoError(err)
		p5, err := e.Input5.Decode(params.MustAt(4))
		ctx.RequireNoError(err)

		r1, r2, r3, r4, r5 := f(ctx, p1, p2, p3, p4, p5)
		output1 := e.Output1.Encode(r1)
		output2 := e.Output2.Encode(r2)
		output3 := e.Output3.Encode(r3)
		output4 := e.Output4.Encode(r4)
		output5 := e.Output5.Encode(r5)

		return isc.NewCallArguments(output1, output2, output3, output4, output5)

	})
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) DecodeOutput(arguments isc.CallArguments) (R1, R2, R3, R4, R5, error) {
	var err error
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	i1, err := arguments.At(0)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o1, err = e.Output1.Decode(i1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i2, err := arguments.At(1)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o2, err = e.Output2.Decode(i2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i3, err := arguments.At(2)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o3, err = e.Output3.Decode(i3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i4, err := arguments.At(3)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o4, err = e.Output4.Decode(i4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	i5, err := arguments.At(4)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	o5, err = e.Output5.Decode(i5)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return o1, o2, o3, o4, o5, nil
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) Call(
	p1 T1, p2 T2, p3 T3, p4 T4, p5 T5,
	send func(msg isc.Message) (isc.CallArguments, error),
) (R1, R2, R3, R4, R5, error) {
	var o1 R1
	var o2 R2
	var o3 R3
	var o4 R4
	var o5 R5

	msg := e.Message(p1, p2, p3, p4, p5)
	res, err := send(msg)
	if err != nil {
		return o1, o2, o3, o4, o5, err
	}

	return e.DecodeOutput(res)
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) Inputs() []FieldArg {
	inputs := make([]FieldArg, 0)

	inputs = append(inputs, e.Input1)
	inputs = append(inputs, e.Input2)
	inputs = append(inputs, e.Input3)
	inputs = append(inputs, e.Input4)
	inputs = append(inputs, e.Input5)

	return inputs
}

func (e EP55[S, T1, T2, T3, T4, T5, R1, R2, R3, R4, R5, I1, I2, I3, I4, I5, O1, O2, O3, O4, O5]) Outputs() []FieldArg {
	outputs := make([]FieldArg, 0)

	outputs = append(outputs, e.Output1)
	outputs = append(outputs, e.Output2)
	outputs = append(outputs, e.Output3)
	outputs = append(outputs, e.Output4)
	outputs = append(outputs, e.Output5)

	return outputs
}
